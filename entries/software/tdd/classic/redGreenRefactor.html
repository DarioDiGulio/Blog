<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../styles/global.css" />
    <!-- UIkit CSS -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/uikit@3.6.3/dist/css/uikit.min.css"
    />

    <!-- UIkit JS -->
    <script src="https://cdn.jsdelivr.net/npm/uikit@3.6.3/dist/js/uikit.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/uikit@3.6.3/dist/js/uikit-icons.min.js"></script>
    <title>Test Driven Development</title>
  </head>

  <body class="uk-margin uk-margin-left uk-margin-right">
    <a href="../../index.html" class="uk-button uk-button-text uk-margin-bottom"
      >Volver</a
    >
    <div class="uk-cover-container uk-height-medium">
      <img src="./tdd.png" alt="Red - Green - Refactor" uk-cover />
    </div>
    <h1 class="uk-heading-divider">Test Driven Development</h1>
    <ul
      class="uk-comment-meta uk-subnav uk-subnav-divider uk-margin-remove-top"
    >
      <li><a href="#">24/06/2021</a></li>
      <li><a href="../../../../index.html">Dario Di Gulio</a></li>
    </ul>
    <span class="uk-label tag">TDD</span>
    <span class="uk-label tag">Diseño de Software</span>
    <span class="uk-label tag">Red, Green, Refactor</span>
    <span class="uk-label tag">Uncle Bob</span>
    <span class="uk-label tag">Kent Beck</span>
    <h2 class="uk-heading-line">Introducción</h2>
    <p class="uk-text-justify">
      <mark>TDD</mark> es una técnica de diseño de software que propone empezar
      por los test, y que el diseño vaya surgiendo de ellos. Pregonada por
      <i>Kent Beck, Robert Martin, Martin Fowler, etc.</i>
      aunque con distintas escuelas entre ellos pero todos coinciden en los
      principales lineamientos.
    </p>
    <p class="uk-text-justify">
      Entre sus ventajas se encuentra una mejor cobertura de los test
      automatizados, un mejor diseño del software y menor presencia de bugs,
      entre otras. Si bien <mark>TDD</mark> no nos garantiza un buen diseño, el
      hecho de hacer las cosas testeables nos lleva a desacoplarlas mejor y eso
      ya es ganancia. De sus ventajas más importantes está la cuestión
      metodológica: <mark>TDD</mark> nos propone abordar la complejidad en pasos
      pequeños (un Test) y esto es mucho más eficiente y satisfactorio como
      metodología de desarrollo. A continuación expondré algunas características
      de la idea clásica y algunos puntos comunes entre las diferentes escuelas,
      a modo introductorio. En artículos futuros intentaremos profundizar en las
      diferencias que existen, sus ventajas y desventajas y las formas que
      existen para aplicarlas.
    </p>
    <h2 class="uk-heading-line">Primero, ¿qué es un Test?</h2>

    <h2 class="uk-heading-line">Etapas: Red, Green y Refactor</h2>
    <p class="uk-text-justify">
      TDD consiste en tres etapas, que son el motor de esta técnica y se
      convierten en un ciclo virtuoso e infinito. Estas tres etapas consisten en
      escribir un test que falle por la razón correcta, hacerlo pasar de la
      manera más simple y aplicar técnicas de refactor en el código resultante.
    </p>
    <div class="uk-flex uk-flex-center uk-flex-column">
      <img src="cicle.png" class="uk-margin" alt="Red - Green - Refactor" />
    </div>
    <p class="uk-text-justify">
      En primer lugar tenemos que identificar, en nuestra planificación, el paso
      hacia adelante testeable, más pequeño posible. En nuestro caso, queremos
      hacer una calculadora desde cero y nuestra primer funcionalidad será la de
      poder sumar. La técnica clásica se trata de tres sencillos pasos que
      desarrollamos a continuación:
    </p>
    <h3 class="uk-heading">Red</h3>
    <p class="uk-text-justify">
      El primer paso que vamos a realizar es
      <mark>escribir un test que falle (RED).</mark> Por supuesto, en esta etapa
      es probable que nuestro código ni siquiera compile. Justamente ahí radica
      el aporte más importante de <mark>TDD</mark> al diseño del software, al
      tener que usar un código que todavía no existe para construir el test, nos
      obliga a pensar primero cómo queremos usarlo, ahí es cuando estamos
      diseñando. Para casos más complejos es importante, en este paso, tener una
      reflexión previa sobre el diseño que vamos a encarar, no en detalle, pero
      sí un panorama general. Lo que sí podría ayudarnos mucho es hacer una
      mínima planificación del problema que queremos resolver: qué pasos
      incluye, qué lugares del código hay que modificar, detalles a tener en
      cuenta, etc. Al dividir el problema en partes es muy común perderse en el
      camino y esta planificación nos ayuda a tener un Norte firme y claro.
    </p>
    <p class="uk-text-justify">
      Nuestro objetivo en este paso, luego de haber diseñado cómo queremos usar
      este código, es lograr que el test compile. Esto significa crear todas las
      propiedades y métodos que el test nos haya pedido pero todo vacío o sin
      valor alguno. Apenas nuestro código compile ya podremos ejecutarlo. Ahí es
      cuando queremos ver al test fallar por la razón correcta. Llamamos razón
      correcta a una respuesta válida (de forma) pero equivocada (de contenido).
      Por ejemplo, sumando 2 y 1, una falla correcta sería un 0 como resultado
      pero no una excepción. Una razón incorrecta por ejemplo en ese caso sería
      error de tipos. Razones incorrectas podrían ser también fallas en el
      escenario que creamos para el test, es decir el estado al que llevamos al
      programa antes de ejecutar el cuerpo del test. Veamos algún ejemplo de
      cómo tendríamos el código en esta etapa.
    </p>
    <div class="uk-flex uk-flex-center uk-flex-column">
      <img src="test.png" class="uk-margin" alt="Red - Green - Refactor" />
      <img src="codeRed.png" class="uk-margin" alt="Red - Green - Refactor" />
    </div>
    <p class="uk-text-justify">
      Veamos ahora un fallo del test por la razón correcta con este código:
    </p>
    <div class="uk-flex uk-flex-center uk-flex-column">
      <img src="rightFail.png" class="uk-margin" alt="Red - Green - Refactor" />
    </div>
    <h3 class="uk-heading">Green</h3>
    <p class="uk-text-justify">
      Una vez creado el código con nuestro diseño aplicado, pasamos al segundo
      paso que se trata de
      <mark>hacer pasar ese test de la forma más sencilla posible (GREEN)</mark
      >, sin preocuparnos por el diseño, ni la performance ni nada de eso. En
      este instante, habiendo visto al test fallar por la razón correcta y ahora
      verlo en verde, tenemos confianza de que nuestro test nos está protegiendo
      bien de esa funcionalidad. De hecho es por eso fundamentalmente que lo
      queremos ver fallar.
    </p>
    <p class="uk-text-justify">
      En esta etapa, nuestro código tiene el siguiente aspecto:
    </p>
    <div class="uk-flex uk-flex-center uk-flex-column">
      <img src="codeGreen.png" class="uk-margin" alt="Red - Green - Refactor" />
    </div>
    <h3 class="uk-heading">Refactor</h3>
    <p class="uk-text-justify">
      Finalmente, luego de estos dos pasos, llegamos al momento de
      <mark>limpiar nuestro código (REFACTOR).</mark> Comenzando por el código
      productivo y en un segundo momento por nuestros test, este es el momento
      de pensar bien nombres de variables, clases y funciones, crear objetos
      nuevos, eliminar duplicaciones de código, etc. Lo interesante de este
      paso, es que a cada pequeño cambio, podemos ejecutar los test e ir
      avanzando con el refactor, con la tranquilidad de que todo sigue
      funcionando igual. En caso de que algo falle, sabemos exactamente dónde se
      encuentra el error y tardaremos, <i>nada</i> en volver para atrás y
      corregirlo.
    </p>
    <p class="uk-text-justify">
      En nuestro ejemplo no tenemos nada útil para mejorar porque es un caso de
      uso muy simple. De todas formas me gustaría destacar que es en esta etapa
      donde, si estamos aplicando bien la técnica más nos vamos a detener. Esto
      es porque es acá donde podremos aplicar técnicas de diseño, patrones,
      técnicas de refactor y cosas más avanzadas que espero podamos conversar en
      este espacio más adelante. Pero a medida que mejoremos nuestra musculatura
      aplicando TDD, crear el Test y hacerlo pasar será algo casi automático o
      relativamente sencillo en la mayoría de los casos.
    </p>
    <p class="uk-text-justify">
      Una recomendación para esta parte: es muy importante, durante el proceso
      de refactor, no permanecer en rojo mucho tiempo. ¿Qué significa
      <i>mucho</i>?, dependerá tu experiencia. Esto es porque perderíamos una de
      las grandes ventajas de usar <mark>TDD</mark> que es, ante un error, no
      estar muy lejos del cambio en el código que lo hizo fallar para poder
      corregirlo rápido. Por esto es recomendable avanzar en el refactor
      mediante lo que llamamos <mark>baby steps</mark>, cosa en la que podemos
      profundizar más adelante, pero básicamente se trata de dar
      consecutivamente el paso más pequeño posible siempre.
    </p>
    <h2 class="uk-heading-line">Conclusión</h2>
    <p class="uk-text-justify">
      TDD trae muchas ventajas a la experiencia de desarrollo, pero también a la
      calidad del producto final. De manera muy sencilla y efectiva, aumenta la
      satisfacción del equipo de desarrollo y también del cliente. Esta es una
      pequeña introducción a este mundo, pero como siguientes pasos, recomiendo
      seguir profundizando en técnicas de refactor, escuelas de TDD y otras
      técnicas de Extreme Programming para complementar. Todos estos temas los
      iremos tratando en las sucesivas entradas de este blog.
    </p>
    <a href="#" uk-totop uk-scroll></a>
  </body>
</html>
